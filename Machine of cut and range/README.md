```markdown
# Машина из отрезка и диапазона

**Ограничение времени**: 5 секунд  
**Ограничение памяти**: 256Mb  
**Ввод**: стандартный ввод или `input.txt`  
**Вывод**: стандартный вывод или `output.txt`

## Условие задачи
Необходимо обрабатывать два типа запросов для массива мощностей машин:
1. Изменение мощности машины (`SET a b`)
2. Подсчет машин в позициях [l, r] с мощностью в диапазоне [x, y] (`GET l r x y`)

## Формат ввода
1. N M - количество машин и запросов (1 ≤ N, M ≤ 10⁵)
2. a₁ a₂ ... aₙ - мощности машин (1 ≤ aᵢ ≤ N)
3. M запросов:
   - `SET a b` - изменить мощность машины на позиции a
   - `GET l r x y` - подсчитать подходящие машины

## Формат вывода
Для каждого запроса `GET` выведите количество машин, удовлетворяющих условиям.

## Пример
**Ввод**  
```
4 4
1 2 3 4
GET 1 2 2 3
GET 1 3 1 3
SET 1 4
GET 1 3 1 3
``

**Вывод**  
```
1
3
2
```

## Решение
Для эффективной реализации требуется структура данных, поддерживающая:
1. Быстрое обновление элементов (O(log n))
2. Быстрый запрос количества элементов в прямоугольнике (O(log² n))

**Рекомендуемые структуры**:
1. **Двумерное дерево отрезков**:
   - Ось X: позиции машин (1..N)
   - Ось Y: значения мощностей (1..N)
   - В узлах хранится количество элементов

2. **Дерево Фенвика для персистентных деревьев**:
   - Основное дерево по позициям
   - В каждом узле - дерево по значениям

**Алгоритм**:
1. Построение структуры данных из исходного массива
2. Для каждого запроса:
   - `SET`: обновляем значение в структуре
   - `GET`: находим количество элементов в прямоугольнике [l..r] × [x..y]

**Сложность**:
- Построение: O(N log N)
- `SET`: O(log N)
- `GET`: O(log² N)

**Примечание**: Для N=10⁵ общая сложность O(M log² N) ≈ 4·10⁷ операций, что укладывается в ограничения.