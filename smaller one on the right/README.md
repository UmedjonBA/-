# Меньший справа

## Условие задачи

Дается массив `a[]` из `N` целых чисел. Для каждого элемента массива необходимо найти количество элементов, расположенных **справа** от него (с большим индексом), которые **строго меньше** текущего элемента.

### Формат ввода
- Первая строка: целое число `N` (1 ≤ N ≤ 10⁵) — количество элементов в массиве.
- Вторая строка: `N` целых чисел `a[i]` (|a[i]| ≤ 10⁹) — элементы массива.

### Формат вывода
- Массив `b[]` той же длины, где `b[i]` равно количеству элементов справа от `a[i]`, которые строго меньше `a[i]`.

### Пример 1
**Ввод:**
```
4
5 2 6 1
```

**Вывод:**
```
2 1 1 0
```

**Объяснение:**
- Для элемента 5 (индекс 0) справа находятся элементы 2, 6, 1. Из них строго меньше 5: 2 и 1 → 2.
- Для элемента 2 (индекс 1) справа 6 и 1. Меньше: только 1 → 1.
- Для элемента 6 (индекс 2) справа 1. Меньше: 1 → 1.
- Для элемента 1 (индекс 3) справа нет элементов → 0.

### Пример 2
**Ввод:**
```
1
-1
```

**Вывод:**
```
0
```

### Пример 3
**Ввод:**
```
2
-1 -1
```

**Вывод:**
```
0 0
```

## Решение
Для эффективного решения задачи с ограничениями (N ≤ 10⁵) необходимо использовать **дерево отрезков** или **дерево Фенвика** (Binary Indexed Tree) для подсчёта элементов. Основные шаги:

1. **Сжатие координат** (если значения элементов большие).
2. **Обратный проход** по массиву (справа налево).
3. Для каждого элемента:
   - Запрос в дереве Фенвика: сколько элементов меньше текущего уже учтено (т.е. находятся справа).
   - Обновление дерева: добавление текущего элемента.

### Сложность
- **Время**: O(N log N) — сжатие координат и операции с деревом Фенвика.
- **Память**: O(N) — хранение дерева и вспомогательных структур.

---

**Примечание**: Отрицательные значения обрабатываются корректно, так как важен относительный порядок элементов.