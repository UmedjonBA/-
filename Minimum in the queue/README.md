```markdown
# Очередь с поддержкой минимума

## Условие задачи
Требуется реализовать структуру данных "Очередь" с дополнительной операцией поиска минимального элемента. Очередь должна поддерживать стандартные операции и быстро возвращать текущий минимум.

### Поддерживаемые операции:
1. `enqueue x` - добавить `x` в конец очереди (вывод "ok")
2. `dequeue` - удалить первый элемент (вывод значение или "error")
3. `front` - показать первый элемент (вывод значение или "error")
4. `size` - текущий размер очереди
5. `clear` - очистить очередь (вывод "ok")
6. `min` - найти минимальный элемент (вывод значение или "error")

### Формат ввода:
- Первая строка: `n` (1 ≤ n ≤ 2·10^5) - количество запросов
- Следующие `n` строк: запросы в указанном формате

### Формат вывода:
Для каждого запроса - соответствующая строка ответа

## Ограничения
- Время: 1 секунда (Java - 3 секунды)
- Память: 256 МБ (Java - 512 МБ)
- Числа: 1 ≤ x ≤ 10^9

## Пример
### Ввод:
```
9
enqueue 2
front
dequeue
size
dequeue
enqueue 1
enqueue 2
size
min
``

### Вывод:
```
ok
2
2
0
error
ok
ok
2
1
```

## Алгоритм решения
1. **Основная структура**:
   - Использовать две стека с поддержкой минимума (реализация очереди на стеках)
   - Первый стек (`in_stack`) - для добавления элементов
   - Второй стек (`out_stack`) - для извлечения элементов

2. **Поддержка минимума**:
   - Для каждого стека хранить текущий минимум
   - При переносе элементов из `in_stack` в `out_stack` пересчитывать минимумы

3. **Операции**:
   - `enqueue` - добавляет в `in_stack`
   - `dequeue` - если `out_stack` пуст, переносит все из `in_stack`
   - `min` - минимум из минимумов двух стеков

## Особенности реализации
- Для эффективного переноса элементов между стеками использовать амортизированный подход
- Хранить в стеке пары (значение, текущий минимум)
- Операция `min` выполняется за O(1) в худшем случае

## Пример работы
1. `enqueue 2` → in_stack: [(2,2)] → "ok"
2. `front` → out_stack пуст → переносим → out_stack: [(2,2)] → front=2
3. `dequeue` → извлекаем 2 → "2"
4. `size` → 0 элементов → "0"
5. `dequeue` → очередь пуста → "error"
6. `enqueue 1` → in_stack: [(1,1)] → "ok"
7. `enqueue 2` → in_stack: [(1,1), (2,1)] → "ok"
8. `size` → 2 элемента → "2"
9. `min` → min(1,1) → "1"

## Примечание
Решение должно эффективно работать при максимальном количестве запросов (200000) в рамках заданных ограничений по времени и памяти.