```markdown
# Деккартова организация

**Ограничение времени**: 2 секунды  
**Ограничение памяти**: 256Mb  
**Ввод**: стандартный ввод или `input.txt`  
**Вывод**: стандартный вывод или `output.txt`  

**В этой задаче запрещено использовать `map`, `set` и аналогичные встроенные структуры.**

Доминик решил пересмотреть свой автопарк и организовать информацию о нем. Для этого он пронумеровал свои машины последовательными целыми числами от 1 до N, а также присвоил каждой машине ключ и приоритет. Доминик уверен, что если расположить машины как вершины в декартовом дереве поиска, то он сможет подбирать нужную тачку на гонку оптимально.

Так как Доминик, как и всегда, торопится на встречу с семьёй, ему нужно построить дерево для хранения информации о машинах за линейное время от числа машин.

### Формат ввода
В первой строке записано число N — количество пар ключ-приоритет. Далее следует N (1 ≤ N ≤ 50000) пар (aᵢ, bᵢ), где aᵢ задаёт ключ i-й машины, а bᵢ — приоритет. Для всех пар |aᵢ|, |bᵢ| ≤ 30000. Более того, aᵢ ≠ aⱼ и bᵢ ≠ bⱼ для всех i ≠ j. Гарантируется, что пары отсортированы по возрастанию aᵢ.

### Формат вывода
Если Доминик выбрал неверные приоритеты или ключи и дерево построить невозможно, то выведите `NO`. Иначе выведите `YES`, а затем N строк, каждая из которых должна описывать вершину (номером вершины считаем номер машины, которую она задаёт). Описание вершины состоит из трёх чисел: номер предка, номер левого сына и номер правого сына. Если у вершины отсутствует предок или какой-либо из сыновей, то выводите на его месте число 0.

Если подходящих деревьев несколько, выведите любое.

### Пример
**Ввод**  
```
7
0 5
1 3
2 2
3 9
4 11
5 4
6 6
``

**Вывод**  
```
YES
2 0 0
3 1 0
0 2 6
6 0 5
4 0 0
3 4 7
6 0 0
```

### Примечания
> «Неважно, что ты стоишь рядом с тачкой и она твоя. Важно другое: то, как ты на ней ездишь! Запомни это» (c) Форсаж
```