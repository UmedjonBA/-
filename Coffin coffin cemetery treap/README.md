```markdown
# Гроб гроб кладбище treap

**Ограничение времени**: 2 секунды  
**Ограничение памяти**: 256Mb  
**Ввод**: стандартный ввод или `input.txt`  
**Вывод**: стандартный вывод или `output.txt`

## Условие задачи
Необходимо реализовать структуру данных на основе декартова дерева (treap), поддерживающую операции:
1. Сумма на подотрезке (`1 L R`)
2. Вставка элемента (`2 x pos`)
3. Удаление элемента (`3 pos`)
4. Присвоение значения на подотрезке (`4 x L R`)
5. Прибавление числа на подотрезке (`5 x L R`)
6. next_permutation на подотрезке (`6 L R`)
7. prev_permutation на подотрезке (`7 L R`)

## Формат ввода
1. n - размер массива (1 ≤ n ≤ 3·10⁴)
2. a₁...aₙ - элементы массива (|aᵢ| ≤ 3·10⁴)
3. q - количество запросов (1 ≤ q ≤ 10⁵)
4. q запросов в формате:
   - `1 L R` - сумма
   - `2 x pos` - вставка
   - `3 pos` - удаление
   - `4 x L R` - присвоение
   - `5 x L R` - прибавление
   - `6 L R` - next_permutation
   - `7 L R` - prev_permutation

## Формат вывода
1. Для каждого запроса типа `1` - сумма
2. После всех запросов - итоговый массив

## Пример
**Ввод**  
```
7
1 2 3 4 5 6 7
8
4 5 1 3
2 3 3
5 2 0 4
7 0 6
6 0 3
3 2
1 1 5
1 0 6
``

**Вывод**  
```
28
40
5 3 7 6 7 5 7
```

## Решение
1. **Декартово дерево по неявному ключу**:
   - Хранит элементы с поддержкой порядка
   - Поддерживает операции split/merge за O(log n)

2. **Дополнительные поля в узлах**:
   - Сумма поддерева
   - Минимум/максимум для перестановок
   - Ленивые операции (присвоение/прибавление)

3. **Алгоритмы**:
   - next_permutation: находим первый убывающий элемент справа
   - prev_permutation: находим первый возрастающий элемент справа

**Сложность**:
- O(log n) для операций 1-5
- O(k + log n) для перестановок (k - длина отрезка)

**Примечание**: Для эффективной реализации перестановок требуется дополнительная информация в узлах о монотонности подотрезков.