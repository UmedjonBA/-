# RMQ + Reverse

**Ограничение времени**: 4 секунды  
**Ограничение памяти**: 64Mb  
**Ввод**: стандартный ввод или `input.txt`  
**Вывод**: стандартный вывод или `output.txt`

## Условие задачи
Необходимо реализовать структуру данных для массива, поддерживающую:
1. Разворот отрезка (`1 l r`)
2. Запрос минимума на отрезке (`2 l r`)

## Формат ввода
1. n m - размер массива и количество запросов (1 ≤ n, m ≤ 10⁵)
2. a₁ a₂ ... aₙ - исходный массив (-10⁹ ≤ aᵢ ≤ 10⁹)
3. m запросов:
   - `1 l r` - развернуть отрезок [l, r]
   - `2 l r` - найти минимум на отрезке [l, r]

## Формат вывода
Для каждого запроса типа `2` выведите минимум на указанном отрезке.

## Пример
**Ввод**  
```
10 7
5 3 2 3 12 6 7 5 10 12
2 4 9
1 4 6
2 1 8
1 1 8
1 8 9
2 1 7
2 3 6
```

**Вывод**  
```
3
2
2
2
```

## Решение
Для эффективной реализации требуется структура данных, поддерживающая:
1. Быстрый разворот отрезка (O(log n))
2. Быстрый запрос минимума (O(log n))

**Рекомендуемая структура**:
- **Декартово дерево по неявному ключу** с поддержкой:
  - Операции reverse (флагом перевёрнутости)
  - Хранения минимума в поддереве

**Алгоритм**:
1. Построение дерева из исходного массива
2. Для каждого запроса:
   - Разворот: помечаем отрезок как перевёрнутый
   - Минимум: находим минимум в заданном диапазоне

**Сложность**:
- O(n) на построение
- O(log n) на каждый запрос

**Примечание**: Для обработки reverse используем отложенные операции (ленивые вычисления).