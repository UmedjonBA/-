```markdown
# Менеджер памяти

## Описание задачи
Реализация менеджера памяти, который обрабатывает запросы на выделение и освобождение блоков памяти в массиве ячеек (пронумерованных от `1` до `N`).  
- **Выделение памяти (`K > 0`)**:
  - Найти самый длинный свободный блок из `K` последовательных ячеек.
  - Если таких блоков несколько, выбрать тот, у которого начальный индекс минимален.
  - Если подходящего блока нет, вернуть `-1`.
- **Освобождение памяти (`-T`)**:
  - Освободить память, выделенную в запросе с номером `T` (если запрос `T` был успешным).
  - Если запрос `T` был отклонён или уже освобождён, игнорировать.

## Ограничения
- Время выполнения: 1 секунда (Java — 3 секунды)
- Память: 64 МБ (Java — 128 МБ)
- `1 ≤ N ≤ 2^31 - 1` (количество ячеек памяти)
- `1 ≤ M ≤ 10^5` (количество запросов)
- Для запроса на выделение: `1 ≤ K ≤ N`
- Для запроса на освобождение: `1 ≤ T < i` (где `i` — номер текущего запроса)

## Формат ввода
- Первая строка: `N` и `M` (размер памяти и количество запросов).
- Следующие `M` строк:
  - Положительное число `K` — запрос на выделение `K` ячеек.
  - Отрицательное число `-T` — запрос на освобождение памяти из запроса `T`.

## Формат вывода
- Для каждого запроса на выделение:
  - Номер первой ячейки выделенного блока (если успешно).
  - `-1` (если невозможно выделить).

## Пример
### Ввод
```
6 8
2
3
-1
3
3
-5
2
2
```

### Вывод
```
1
3
-1
-1
1
-1
``

## Решение
### Подход
1. **Структуры данных**:
   - Использовать **TreeSet** или **приоритетные очереди** для хранения свободных блоков, отсортированных по длине и начальному индексу.
   - Хранить информацию о выделенных блоках в **HashMap** (ключ — номер запроса, значение — `[start, size]`).

2. **Алгоритм**:
   - **Выделение (`K`)**:
     - Найти подходящий свободный блок (максимальной длины с минимальным начальным индексом).
     - Разделить блок на занятую и оставшуюся свободную части.
   - **Освобождение (`-T`)**:
     - Удалить блок из занятых и добавить его в свободные, объединяя с соседними свободными блоками.

### Оптимизация
- Для быстрого поиска свободных блоков использовать **TreeSet<Block>** с компаратором:
  ```java
  Comparator<Block> comparator = (a, b) -> {
      if (a.size != b.size) return Integer.compare(b.size, a.size); // Сначала большие блоки
      return Integer.compare(a.start, b.start); // При равных размерах — меньший start
  };
  ```
- Для объединения освобождённых блоков проверять их соседей в **TreeSet**.
