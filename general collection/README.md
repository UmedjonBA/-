```markdown
# Общая коллекция

**Ограничение времени**: 10 секунд  
**Ограничение памяти**: 512Mb  
**Ввод**: стандартный ввод или `input.txt`  
**Вывод**: стандартный вывод или `output.txt`

## Условие задачи
Найти пересечение двух мультимножеств (коллекций покемонов) с учетом кратности.

## Формат ввода
1. N - количество покемонов у Хэша (1 ≤ N ≤ 3·10⁶)
2. a₁ a₂ ... aₙ - номера покемонов Хэша (1 ≤ aᵢ ≤ 10⁹)
3. M - количество покемонов у Мисти (1 ≤ M ≤ 3·10⁶)
4. b₁ b₂ ... bₘ - номера покемонов Мисти (1 ≤ bᵢ ≤ 10⁹)

## Формат вывода
Номера общих покемонов с учетом кратности (минимальное количество вхождений в обеих коллекциях)

## Примеры
**Пример 1**  
Ввод:  
```
5
1 2 1 3 10
3
1 1 11
``
Вывод:  
```
2
1 1
```

**Пример 2**  
Ввод:  
```
5
1 1 2 2 1
5
2 2 1 1 2
```  
Вывод:  
```
4
2 2 1 1
```

## Решение
1. **Использование хэш-таблиц**:
   - Создаем `unordered_map<int, int>` для подсчета покемонов у Хэша
   - Для каждого покемона Мисти проверяем наличие в хэш-таблице Хэша
   - Уменьшаем счетчик при совпадении и добавляем в результат

2. **Оптимизации**:
   - Предварительное резервирование памяти для хэш-таблиц
   - Пакетная обработка входных данных

3. **Алгоритм**:
   - Считать коллекцию Хэша в хэш-таблицу
   - Для каждого покемона Мисти проверять наличие в таблице
   - При наличии - добавить в результат и уменьшить счетчик

**Сложность**:
- O(N + M) в среднем случае
- O(N) по памяти

**Примечание**: Для 3·10⁶ элементов важно использовать эффективные структуры данных и минимизировать аллокации памяти.